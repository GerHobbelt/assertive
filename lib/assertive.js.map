{"version":3,"sources":["../src/assertive.js"],"names":["global","Function","assert","_","require","toString","Object","prototype","green","x","red","clear","process","stdout","isTTY","error","message","explanation","errProps","err","Error","assign","nameNegative","name","charAt","toUpperCase","slice","asRegExp","re","flags","multiline","ignoreCase","source","stringifyReplacer","key","val","isRegExp","isObject","isArray","toPairs","sortBy","fromPairs","value","stringify","isNaN","json","JSON","className","constructor","test","stack","e","handleArgs","self","count","args","help","negated","isString","argc","length","max","indexOf","n","wantedArgCount","isNumber","join","pop","actualArgs","call","functionSource","wantedArgNames","match","wanted","actual","type","TypeError","abbreviate","threshold","str","desc","getNameOfType","isFunction","types","implodeNicely","list","conjunction","first","last","isType","typeName","isDate","getTypeName","find","partial","assertSync","truthy","bool","arguments","expect","equal","expected","deepEqual","isEqual","wrongLooks","rightLooks","include","needle","haystack","what","problem","contained","includes","map","s","regexp","string","oops","called","matched","throws","fn","undefined","hasType","expectedType","stringType","badArg","suggestions","typeMatches","toBeOrNotToBe","positiveAssertions","forEach","_oneTest","apply","isPromiseAlike","p","then","resolves","testee","identity","catch","rejects","module","exports"],"mappings":"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","file":"assertive.js","sourcesContent":["/*\n * Copyright (c) 2013, Groupon, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of GROUPON nor the names of its contributors may be\n * used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n'use strict';\n\n// eat _ off the global scope, or require it ourselves if missing\n// eslint-disable-next-line no-new-func\nconst global = Function('return this')();\nlet assert;\n\n// eslint-disable-next-line global-require\nconst _ = global._ || require('lodash');\n\nconst toString = Object.prototype.toString;\n\nlet green = x => `\\x1B[32m${x}\\x1B[39m`;\nlet red = x => `\\x1B[31m${x}\\x1B[39m`;\nlet clear = '\\x1b[39;49;00m';\n\nif (!(global.process && process.stdout && process.stdout.isTTY)) {\n  red = x => `${x}`;\n  green = red;\n  clear = '';\n}\n\nfunction error(message, explanation, errProps) {\n  if (explanation != null) {\n    message = `Assertion failed: ${explanation}\\n${clear}${message}`;\n  }\n  const err = new Error(message);\n  if (errProps) _.assign(err, errProps);\n  return err;\n}\n\nfunction nameNegative(name) {\n  if (name === 'truthy') {\n    return 'falsey';\n  }\n  if (name === 'resolves') {\n    return 'rejects';\n  }\n  return `not${name.charAt().toUpperCase()}${name.slice(1)}`;\n}\n\nfunction asRegExp(re) {\n  let flags = '';\n  if (re.global) flags += 'g';\n  if (re.multiline) flags += 'm';\n  if (re.ignoreCase) flags += 'i';\n  return `/${re.source}/${flags}`;\n}\n\nfunction stringifyReplacer(key, val) {\n  if (typeof val === 'function') return toString(val);\n  if (_.isRegExp(val)) return asRegExp(val);\n  if (_.isObject(val) && !_.isArray(val)) {\n    return _(val)\n      .toPairs()\n      .sortBy(0)\n      .fromPairs()\n      .value();\n  }\n  return val;\n}\n\nfunction stringify(x) {\n  if (x == null) return `${x}`;\n  if (_.isNaN(x)) return 'NaN';\n  if (_.isRegExp(x)) return asRegExp(x);\n  if (typeof x === 'symbol') return x.toString();\n  const json = JSON.stringify(x, stringifyReplacer, 2);\n  const className = x && x.constructor && x.constructor.name;\n  if (\n    typeof x !== 'object' ||\n    className === 'Object' ||\n    className === 'Array'\n  ) {\n    return json;\n  }\n\n  if (x instanceof Error || /Error/.test(className)) {\n    if (json === '{}') {\n      return x.stack;\n    }\n    return `${x.stack}\\nwith error metadata:\\n${json}`;\n  }\n  if (x.toString === toString) {\n    return className;\n  }\n  try {\n    return `${className}[${x}]`;\n  } catch (e) {\n    return className;\n  }\n}\n\n// assert that the function got `count` args (if an integer), one of the number\n// of args (if an array of legal counts), and if it was an array and the count\n// was equal to the last option (fully populated), that the first arg is a String\n// (that test's semantic explanation)\nfunction handleArgs(self, count, args, name, help) {\n  let negated = false;\n  if (_.isString(self)) {\n    negated = true;\n    name = nameNegative(name);\n  }\n\n  const argc = args.length;\n  if (argc === count) return [name, negated];\n\n  let max = '';\n  if (_.isArray(count) && count.indexOf(argc) !== -1) {\n    const n = count[count.length - 1];\n    if (argc !== n || _.isString(args[0])) return [name, negated];\n    max = `,\\nand when called with ${\n      n\n    } args, the first arg must be a docstring`;\n  }\n\n  let wantedArgCount;\n  if (_.isNumber(count)) {\n    wantedArgCount = `${count} argument`;\n  } else {\n    wantedArgCount = count.slice(0, -1).join(', ');\n    count = count.pop();\n    wantedArgCount = `${wantedArgCount} or ${count} argument`;\n  }\n  if (count !== 1) wantedArgCount += 's';\n\n  const actualArgs = stringify([].slice.call(args)).slice(1, -1);\n\n  const functionSource = Function.prototype.toString.call(assert[name]);\n  let wantedArgNames = functionSource.match(/^function\\s*[^(]*\\s*\\(([^)]*)/)[1];\n  if (max) {\n    wantedArgNames = `explanation, ${wantedArgNames}`;\n  }\n\n  const wanted = `${name}(${wantedArgNames})`;\n  const actual = `${name}(${actualArgs})`;\n  const message = `${green(wanted)} needs ${wantedArgCount + max}\nyour usage: ${red(actual)}`;\n\n  if (typeof help === 'function') {\n    help = help();\n  }\n  throw error(message, help);\n}\n\nfunction type(x) {\n  if (_.isString(x)) return 'String';\n  if (_.isNumber(x)) return 'Number';\n  if (_.isRegExp(x)) return 'RegExp';\n  if (_.isArray(x)) return 'Array';\n  throw new TypeError(`unsupported type: ${x}`);\n}\n\nfunction abbreviate(name, value, threshold) {\n  const str = stringify(value);\n  if (str.length <= (threshold || 1024)) return str;\n  let desc = `length: ${value.length}`;\n  if (_.isArray(value)) desc += `; ${str.length} JSON encoded`;\n  if (name) name += ' ';\n  return `${name}${type(value)}[${desc}]`;\n}\n\n// translates any argument we were meant to interpret as a type, into its name\nfunction getNameOfType(x) {\n  switch (false) {\n    case !(x == null):\n      return `${x}`; // null / undefined\n    case !_.isString(x):\n      return x;\n    case !_.isFunction(x):\n      return x.name;\n    case !_.isNaN(x):\n      return 'NaN';\n    default:\n      return x;\n  }\n}\n\n// listing the most specific types first lets us iterate in order and verify that\n// the expected type was the first match\nconst types = [\n  'null',\n  'Date',\n  'Array',\n  'String',\n  'RegExp',\n  'Boolean',\n  'Function',\n  'Object',\n  'NaN',\n  'Number',\n  'undefined',\n];\n\nfunction implodeNicely(list, conjunction) {\n  const first = list.slice(0, -1).join(', ');\n  const last = list[list.length - 1];\n  return `${first} ${conjunction || 'and'} ${last}`;\n}\n\nfunction isType(value, typeName) {\n  if (typeName === 'Date') return _.isDate(value) && !_.isNaN(+value);\n  return _[`is${typeName[0].toUpperCase()}${typeName.slice(1)}`](value);\n}\n\n// gets the name of the type that value is an incarnation of\nfunction getTypeName(value) {\n  return _.find(types, _.partial(isType, value));\n}\n\n/* eslint-disable prefer-rest-params */\nconst assertSync = {\n  truthy(bool) {\n    const args = handleArgs(this, [1, 2], arguments, 'truthy');\n    const name = args[0];\n    const negated = args[1];\n    let explanation;\n    if (arguments.length === 2) {\n      explanation = arguments[0];\n      bool = arguments[1];\n    }\n    if ((!bool && !negated) || (bool && negated)) {\n      throw error(\n        `Expected ${red(stringify(bool))} to be ${name}`,\n        explanation\n      );\n    }\n  },\n\n  expect(bool) {\n    let explanation;\n    if (arguments.length === 2) {\n      explanation = arguments[0];\n      bool = arguments[1];\n    }\n    if (explanation) return assertSync.equal(explanation, true, bool);\n    return assertSync.equal(true, bool);\n  },\n\n  equal(expected, actual) {\n    let explanation;\n    const negated = handleArgs(this, [2, 3], arguments, 'equal')[1];\n    if (arguments.length === 3) {\n      explanation = arguments[0];\n      expected = arguments[1];\n      actual = arguments[2];\n    }\n    if (negated) {\n      if (expected === actual) {\n        throw error(\n          `notEqual assertion expected ${red(stringify(actual))}` +\n            ' to be exactly anything else',\n          explanation\n        );\n      }\n    } else if (expected !== actual) {\n      throw error(\n        `Expected: ${green(stringify(expected))}\\nActually: ` +\n          `${red(stringify(actual))}`,\n        explanation,\n        { actual, expected }\n      );\n    }\n  },\n\n  deepEqual(expected, actual) {\n    let explanation;\n    const negated = handleArgs(this, [2, 3], arguments, 'deepEqual')[1];\n    if (arguments.length === 3) {\n      explanation = arguments[0];\n      expected = arguments[1];\n      actual = arguments[2];\n    }\n    const isEqual = _.isEqual(expected, actual);\n    if ((isEqual && !negated) || (!isEqual && negated)) return;\n\n    const wrongLooks = stringify(actual);\n    if (negated) {\n      throw error(\n        `notDeepEqual assertion expected exactly anything else but\n${red(wrongLooks)}`,\n        explanation\n      );\n    }\n\n    const rightLooks = stringify(expected);\n    let message;\n    if (wrongLooks === rightLooks) {\n      message =\n        `deepEqual ${green(rightLooks)} failed on something that\\n` +\n        'serializes to the same result (likely some function)';\n    } else {\n      message = `Expected: ${wrongLooks} to deepEqual ${rightLooks}`;\n    }\n\n    throw error(message, explanation, { expected, actual });\n  },\n\n  include(needle, haystack) {\n    const args = handleArgs(this, [2, 3], arguments, 'include');\n    const name = args[0];\n    const negated = args[1];\n    let explanation;\n    if (arguments.length === 3) {\n      explanation = arguments[0];\n      needle = arguments[1];\n      haystack = arguments[2];\n    }\n    if (_.isString(haystack)) {\n      if (needle === '') {\n        const what = negated ? 'always-failing test' : 'no-op test';\n        throw error(`${what} detected: all strings contain the empty string!`);\n      }\n      if (!_.isString(needle) && !_.isNumber(needle) && !_.isRegExp(needle)) {\n        const problem =\n          'needs a RegExp/String/Number needle for a String haystack';\n        throw new TypeError(\n          `${name} ${problem}; you used:\\n` +\n            `${name} ${green(stringify(haystack))}, ${red(stringify(needle))}`\n        );\n      }\n    } else if (!_.isArray(haystack)) {\n      needle = stringify(needle);\n      throw new TypeError(`${name} takes a String or Array haystack; you used:\n${name} ${red(stringify(haystack))}, ${needle}`);\n    }\n\n    let contained;\n    if (_.isString(haystack)) {\n      if (_.isRegExp(needle)) {\n        contained = haystack.match(needle);\n      } else {\n        contained = haystack.indexOf(needle) !== -1;\n      }\n    } else {\n      contained = _.includes(haystack, needle);\n    }\n\n    if (negated) {\n      if (contained) {\n        // eslint-disable-next-line prefer-template\n        let message = `${'notInclude expected needle not to be found in ' +\n          `haystack\\n- needle: ${stringify(needle)}\\n haystack: `}${abbreviate(\n          '',\n          haystack\n        )}`;\n        if (_.isString(haystack) && _.isRegExp(needle)) {\n          message += ', but found:\\n';\n          if (needle.global) {\n            message += contained.map(s => `* ${red(stringify(s))}`).join('\\n');\n          } else {\n            message += `* ${red(stringify(contained[0]))}`;\n          }\n        }\n        throw error(message, explanation);\n      }\n    } else if (!contained) {\n      throw error(\n        `${name} expected needle to be found in haystack\\n` +\n          `- needle: ${stringify(needle)}\\n` +\n          `haystack: ${abbreviate('', haystack)}`,\n        explanation\n      );\n    }\n  },\n\n  match(regexp, string) {\n    const args = handleArgs(this, [2, 3], arguments, 'match');\n    const name = args[0];\n    const negated = args[1];\n    let explanation;\n    if (arguments.length === 3) {\n      explanation = arguments[0];\n      regexp = arguments[1];\n      string = arguments[2];\n    }\n\n    const re = _.isRegExp(regexp);\n    if (!re || !_.isString(string)) {\n      string = abbreviate('string', string);\n      const oops = re\n        ? 'string arg is not a String'\n        : 'regexp arg is not a RegExp';\n      const called = `${name} ${stringify(regexp)}, ${red(string)}`;\n      throw new TypeError(`${name}: ${oops}; you used:\\n${called}`);\n    }\n\n    const matched = regexp.test(string);\n    if (negated) {\n      if (!matched) return;\n      let message =\n        `Expected: ${stringify(regexp)}\\nnot to match: ` +\n        `${red(abbreviate('string', string))}`;\n      if (regexp.global) {\n        const count = string.match(regexp).length;\n        message += `\\nMatches: ${red(count)}`;\n      }\n      throw error(message, explanation);\n    }\n    if (!matched) {\n      throw error(\n        `Expected: ${stringify(regexp)}\\nto match: ` +\n          `${red(abbreviate('string', string))}`,\n        explanation\n      );\n    }\n  },\n\n  throws(fn) {\n    const args = handleArgs(this, [1, 2], arguments, 'throws');\n    const name = args[0];\n    const negated = args[1];\n    let explanation;\n    if (arguments.length === 2) {\n      explanation = arguments[0];\n      fn = arguments[1];\n    }\n    if (typeof explanation === 'function') {\n      fn = explanation;\n      explanation = undefined;\n    }\n    if (typeof fn !== 'function') {\n      throw error(`${name} expects ${green('a function')} but got ${red(fn)}`);\n    }\n\n    try {\n      fn();\n    } catch (err) {\n      if (negated) {\n        throw error(\n          `Threw an exception despite ${name} assertion:\\n` + `${err.message}`,\n          explanation\n        );\n      }\n      return err;\n    }\n\n    if (negated) return undefined;\n    throw error(\"Didn't throw an exception as expected to\", explanation);\n  },\n\n  hasType(expectedType, value) {\n    const args = handleArgs(this, [2, 3], arguments, 'hasType');\n    const name = args[0];\n    const negated = args[1];\n    let explanation;\n    if (arguments.length === 3) {\n      explanation = arguments[0];\n      expectedType = arguments[1];\n      value = arguments[2];\n    }\n\n    const stringType = getNameOfType(expectedType);\n    if (types.indexOf(stringType) === -1) {\n      const badArg = stringify(expectedType);\n      const suggestions = implodeNicely(types, 'or');\n      throw new TypeError(\n        `${name}: unknown expectedType ${badArg}; you used:\\n${name} ` +\n          `${red(badArg)}, ${stringify(value)}\\nDid you mean ${suggestions}?`\n      );\n    }\n\n    const typeMatches = stringType === getTypeName(value);\n    if ((!typeMatches && !negated) || (typeMatches && negated)) {\n      value = red(stringify(value));\n      const toBeOrNotToBe = `${negated ? 'not ' : ''}to be`;\n      const message = `Expected value ${value} ${toBeOrNotToBe} of type ${\n        stringType\n      }`;\n      throw error(message, explanation);\n    }\n  },\n};\n\n// produce negatived versions of all the common assertion functions\nconst positiveAssertions = [\n  'truthy',\n  'equal',\n  'deepEqual',\n  'include',\n  'match',\n  'throws',\n  'hasType',\n];\npositiveAssertions.forEach(name => {\n  assertSync[nameNegative(name)] = function _oneTest() {\n    return assertSync[name].apply('!', arguments);\n  };\n});\n\n// borrowed from Q\nfunction isPromiseAlike(p) {\n  return p === Object(p) && typeof p.then === 'function';\n}\n\n// promise-specific tests\nassert = {\n  resolves(testee) {\n    const name = handleArgs(this, [1, 2], arguments, 'resolves')[0];\n    let explanation;\n    if (arguments.length === 2) {\n      explanation = arguments[0];\n      testee = arguments[1];\n    }\n\n    if (!isPromiseAlike(testee)) {\n      throw error(\n        `${name} expects ${green('a promise')} but got ${red(\n          stringify(testee)\n        )}`\n      );\n    }\n\n    if (name === 'rejects') {\n      return testee.then(() => {\n        throw error(\"Promise wasn't rejected as expected to\", explanation);\n      }, _.identity);\n    }\n    return testee.catch(err => {\n      throw error(\n        'Promise was rejected despite resolves assertion:\\n' +\n          `${(err && err.message) || err}`,\n        explanation\n      );\n    });\n  },\n\n  rejects() {\n    return assert.resolves.apply('!', arguments);\n  },\n};\n\n// union of promise-specific and promise-aware wrapped synchronous tests\n_.forEach(assertSync || {}, (fn, name) => {\n  assert[name] = function _oneTest() {\n    if (arguments.length === 0) return fn();\n    const args = [].slice.call(arguments);\n    const testee = args.pop();\n    if (isPromiseAlike(testee)) {\n      return testee.then(val => fn(...args, val));\n    }\n    return fn(...args, testee);\n  };\n});\n\n// export as a module to node - or to the global scope, if not\nif (typeof module !== 'undefined' && module && module.exports) {\n  module.exports = assert;\n} else {\n  global.assert = assert;\n}\n"]}