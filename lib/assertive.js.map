{"version":3,"sources":["../src/assertive.js"],"names":["assert","isEqual","require","toString","Object","prototype","green","x","red","clear","process","stdout","isTTY","is","reduce","o","t","call","obj","NaN","Number","isNaN","Boolean","Undefined","undefined","Null","Array","isArray","error","message","explanation","errProps","err","Error","keys","forEach","prop","nameNegative","name","charAt","toUpperCase","slice","asRegExp","re","flags","global","multiline","ignoreCase","source","stringifyReplacer","key","val","RegExp","sort","p","stringify","json","JSON","className","constructor","test","stack","e","handleArgs","self","count","args","help","negated","String","argc","length","max","indexOf","n","wantedArgCount","join","pop","actualArgs","functionSource","Function","wantedArgNames","match","wanted","actual","type","TypeError","abbreviate","value","threshold","str","desc","getNameOfType","types","implodeNicely","list","conjunction","first","last","isType","typeName","Date","getTypeName","filter","bind","assertSync","truthy","bool","arguments","expect","equal","expected","deepEqual","isEq","wrongLooks","rightLooks","include","needle","haystack","what","problem","contained","map","s","regexp","string","oops","called","matched","throws","fn","hasType","expectedType","stringType","badArg","suggestions","typeMatches","toBeOrNotToBe","positiveAssertions","_oneTest","apply","isPromiseAlike","then","resolves","testee","catch","rejects","module","exports"],"mappings":"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","file":"assertive.js","sourcesContent":["/*\n * Copyright (c) 2013, Groupon, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of GROUPON nor the names of its contributors may be\n * used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n'use strict';\n\nlet assert;\n\nconst isEqual = require('lodash.isequal');\n\nconst toString = Object.prototype.toString;\n\nlet green = x => `\\x1B[32m${x}\\x1B[39m`;\nlet red = x => `\\x1B[31m${x}\\x1B[39m`;\nlet clear = '\\x1b[39;49;00m';\n\nif (!(typeof process === 'object' && process.stdout && process.stdout.isTTY)) {\n  red = x => `${x}`;\n  green = red;\n  clear = '';\n}\n\n// simplified isFoo versions to remove lodash/underscore dependency\nconst is = ['Array', 'RegExp', 'String', 'Number', 'Date', 'Function'].reduce(\n  (o, t) => ({\n    ...o,\n    [t]: obj => toString.call(obj) === `[object ${t}]`,\n  }),\n  {\n    NaN(obj) {\n      return is.Number(obj) && isNaN(obj);\n    },\n    Object(obj) {\n      const t = typeof obj;\n      return t === 'function' || (t === 'object' && !!obj);\n    },\n    Boolean(obj) {\n      return (\n        obj === true ||\n        obj === false ||\n        toString.call(obj) === '[object Boolean]'\n      );\n    },\n    Undefined(obj) {\n      return obj === undefined;\n    },\n    Null(obj) {\n      return obj === null;\n    },\n  }\n);\nif (Array.isArray) is.Array = Array.isArray;\n\nfunction error(message, explanation, errProps) {\n  if (explanation != null) {\n    message = `Assertion failed: ${explanation}\\n${clear}${message}`;\n  }\n  const err = new Error(message);\n  if (errProps) {\n    Object.keys(errProps).forEach(prop => {\n      err[prop] = errProps[prop];\n    });\n  }\n  return err;\n}\n\nfunction nameNegative(name) {\n  if (name === 'truthy') {\n    return 'falsey';\n  }\n  if (name === 'resolves') {\n    return 'rejects';\n  }\n  return `not${name.charAt().toUpperCase()}${name.slice(1)}`;\n}\n\nfunction asRegExp(re) {\n  let flags = '';\n  if (re.global) flags += 'g';\n  if (re.multiline) flags += 'm';\n  if (re.ignoreCase) flags += 'i';\n  return `/${re.source}/${flags}`;\n}\n\nfunction stringifyReplacer(key, val) {\n  if (typeof val === 'function') return toString.call(val);\n  if (is.RegExp(val)) return asRegExp(val);\n  if (is.Object(val) && !is.Array(val)) {\n    return Object.keys(val)\n      .sort()\n      .reduce((o, p) => ({ ...o, [p]: val[p] }), {});\n  }\n  return val;\n}\n\nfunction stringify(x) {\n  if (x == null) return `${x}`;\n  if (is.NaN(x)) return 'NaN';\n  if (is.RegExp(x)) return asRegExp(x);\n  if (typeof x === 'symbol') return x.toString();\n  const json = JSON.stringify(x, stringifyReplacer, 2);\n  const className = x && x.constructor && x.constructor.name;\n  if (\n    typeof x !== 'object' ||\n    className === 'Object' ||\n    className === 'Array'\n  ) {\n    return json;\n  }\n\n  if (x instanceof Error || /Error/.test(className)) {\n    if (json === '{}') {\n      return x.stack;\n    }\n    return `${x.stack}\\nwith error metadata:\\n${json}`;\n  }\n  if (x.toString === toString) {\n    return className;\n  }\n  try {\n    return `${className}[${x}]`;\n  } catch (e) {\n    return className;\n  }\n}\n\n// assert that the function got `count` args (if an integer), one of the number\n// of args (if an array of legal counts), and if it was an array and the count\n// was equal to the last option (fully populated), that the first arg is a String\n// (that test's semantic explanation)\nfunction handleArgs(self, count, args, name, help) {\n  let negated = false;\n  if (is.String(self)) {\n    negated = true;\n    name = nameNegative(name);\n  }\n\n  const argc = args.length;\n  if (argc === count) return [name, negated];\n\n  let max = '';\n  if (is.Array(count) && count.indexOf(argc) !== -1) {\n    const n = count[count.length - 1];\n    if (argc !== n || is.String(args[0])) return [name, negated];\n    max = `,\\nand when called with ${n} args, the first arg must be a docstring`;\n  }\n\n  let wantedArgCount;\n  if (is.Number(count)) {\n    wantedArgCount = `${count} argument`;\n  } else {\n    wantedArgCount = count.slice(0, -1).join(', ');\n    count = count.pop();\n    wantedArgCount = `${wantedArgCount} or ${count} argument`;\n  }\n  if (count !== 1) wantedArgCount += 's';\n\n  const actualArgs = stringify([].slice.call(args)).slice(1, -1);\n\n  const functionSource = Function.prototype.toString.call(assert[name]);\n  let wantedArgNames = functionSource.match(/^function\\s*[^(]*\\s*\\(([^)]*)/)[1];\n  if (max) {\n    wantedArgNames = `explanation, ${wantedArgNames}`;\n  }\n\n  const wanted = `${name}(${wantedArgNames})`;\n  const actual = `${name}(${actualArgs})`;\n  const message = `${green(wanted)} needs ${wantedArgCount + max}\nyour usage: ${red(actual)}`;\n\n  if (typeof help === 'function') {\n    help = help();\n  }\n  throw error(message, help);\n}\n\nfunction type(x) {\n  if (is.String(x)) return 'String';\n  if (is.Number(x)) return 'Number';\n  if (is.RegExp(x)) return 'RegExp';\n  if (is.Array(x)) return 'Array';\n  throw new TypeError(`unsupported type: ${x}`);\n}\n\nfunction abbreviate(name, value, threshold) {\n  const str = stringify(value);\n  if (str.length <= (threshold || 1024)) return str;\n  let desc = `length: ${value.length}`;\n  if (is.Array(value)) desc += `; ${str.length} JSON encoded`;\n  if (name) name += ' ';\n  return `${name}${type(value)}[${desc}]`;\n}\n\n// translates any argument we were meant to interpret as a type, into its name\nfunction getNameOfType(x) {\n  switch (false) {\n    case !(x == null):\n      return `${x}`; // null / undefined\n    case !is.String(x):\n      return x;\n    case !is.Function(x):\n      return x.name;\n    case !is.NaN(x):\n      return 'NaN';\n    default:\n      return x;\n  }\n}\n\n// listing the most specific types first lets us iterate in order and verify that\n// the expected type was the first match\nconst types = [\n  'null',\n  'Date',\n  'Array',\n  'String',\n  'RegExp',\n  'Boolean',\n  'Function',\n  'Object',\n  'NaN',\n  'Number',\n  'undefined',\n];\n\nfunction implodeNicely(list, conjunction) {\n  const first = list.slice(0, -1).join(', ');\n  const last = list[list.length - 1];\n  return `${first} ${conjunction || 'and'} ${last}`;\n}\n\nfunction isType(value, typeName) {\n  if (typeName === 'Date') return is.Date(value) && !is.NaN(+value);\n  return is[`${typeName[0].toUpperCase()}${typeName.slice(1)}`](value);\n}\n\n// gets the name of the type that value is an incarnation of\nfunction getTypeName(value) {\n  return types.filter(isType.bind(null, value))[0];\n}\n\nconst assertSync = {\n  truthy(bool) {\n    const args = handleArgs(this, [1, 2], arguments, 'truthy');\n    const name = args[0];\n    const negated = args[1];\n    let explanation;\n    if (arguments.length === 2) {\n      explanation = arguments[0];\n      bool = arguments[1];\n    }\n    if ((!bool && !negated) || (bool && negated)) {\n      throw error(\n        `Expected ${red(stringify(bool))} to be ${name}`,\n        explanation\n      );\n    }\n  },\n\n  expect(bool) {\n    let explanation;\n    if (arguments.length === 2) {\n      explanation = arguments[0];\n      bool = arguments[1];\n    }\n    if (explanation) return assertSync.equal(explanation, true, bool);\n    return assertSync.equal(true, bool);\n  },\n\n  equal(expected, actual) {\n    let explanation;\n    const negated = handleArgs(this, [2, 3], arguments, 'equal')[1];\n    if (arguments.length === 3) {\n      explanation = arguments[0];\n      expected = arguments[1];\n      actual = arguments[2];\n    }\n    if (negated) {\n      if (expected === actual) {\n        throw error(\n          `notEqual assertion expected ${red(stringify(actual))}` +\n            ' to be exactly anything else',\n          explanation\n        );\n      }\n    } else if (expected !== actual) {\n      throw error(\n        `Expected: ${green(stringify(expected))}\\nActually: ` +\n          `${red(stringify(actual))}`,\n        explanation,\n        { actual, expected }\n      );\n    }\n  },\n\n  deepEqual(expected, actual) {\n    let explanation;\n    const negated = handleArgs(this, [2, 3], arguments, 'deepEqual')[1];\n    if (arguments.length === 3) {\n      explanation = arguments[0];\n      expected = arguments[1];\n      actual = arguments[2];\n    }\n    const isEq = isEqual(expected, actual);\n    if ((isEq && !negated) || (!isEq && negated)) return;\n\n    const wrongLooks = stringify(actual);\n    if (negated) {\n      throw error(\n        `notDeepEqual assertion expected exactly anything else but\n${red(wrongLooks)}`,\n        explanation\n      );\n    }\n\n    const rightLooks = stringify(expected);\n    let message;\n    if (wrongLooks === rightLooks) {\n      message =\n        `deepEqual ${green(rightLooks)} failed on something that\\n` +\n        'serializes to the same result (likely some function)';\n    } else {\n      message = `Expected: ${wrongLooks} to deepEqual ${rightLooks}`;\n    }\n\n    throw error(message, explanation, { expected, actual });\n  },\n\n  include(needle, haystack) {\n    const args = handleArgs(this, [2, 3], arguments, 'include');\n    const name = args[0];\n    const negated = args[1];\n    let explanation;\n    if (arguments.length === 3) {\n      explanation = arguments[0];\n      needle = arguments[1];\n      haystack = arguments[2];\n    }\n    if (is.String(haystack)) {\n      if (needle === '') {\n        const what = negated ? 'always-failing test' : 'no-op test';\n        throw error(`${what} detected: all strings contain the empty string!`);\n      }\n      if (!is.String(needle) && !is.Number(needle) && !is.RegExp(needle)) {\n        const problem =\n          'needs a RegExp/String/Number needle for a String haystack';\n        throw new TypeError(\n          `${name} ${problem}; you used:\\n` +\n            `${name} ${green(stringify(haystack))}, ${red(stringify(needle))}`\n        );\n      }\n    } else if (!is.Array(haystack)) {\n      needle = stringify(needle);\n      throw new TypeError(`${name} takes a String or Array haystack; you used:\n${name} ${red(stringify(haystack))}, ${needle}`);\n    }\n\n    const contained =\n      is.String(haystack) && is.RegExp(needle)\n        ? haystack.match(needle)\n        : haystack.indexOf(needle) > -1;\n\n    if (negated) {\n      if (contained) {\n        let message = `${'notInclude expected needle not to be found in ' +\n          `haystack\\n- needle: ${stringify(needle)}\\n haystack: `}${abbreviate(\n          '',\n          haystack\n        )}`;\n        if (is.String(haystack) && is.RegExp(needle)) {\n          message += ', but found:\\n';\n          if (needle.global) {\n            message += contained.map(s => `* ${red(stringify(s))}`).join('\\n');\n          } else {\n            message += `* ${red(stringify(contained[0]))}`;\n          }\n        }\n        throw error(message, explanation);\n      }\n    } else if (!contained) {\n      throw error(\n        `${name} expected needle to be found in haystack\\n` +\n          `- needle: ${stringify(needle)}\\n` +\n          `haystack: ${abbreviate('', haystack)}`,\n        explanation\n      );\n    }\n  },\n\n  match(regexp, string) {\n    const args = handleArgs(this, [2, 3], arguments, 'match');\n    const name = args[0];\n    const negated = args[1];\n    let explanation;\n    if (arguments.length === 3) {\n      explanation = arguments[0];\n      regexp = arguments[1];\n      string = arguments[2];\n    }\n\n    const re = is.RegExp(regexp);\n    if (!re || !is.String(string)) {\n      string = abbreviate('string', string);\n      const oops = re\n        ? 'string arg is not a String'\n        : 'regexp arg is not a RegExp';\n      const called = `${name} ${stringify(regexp)}, ${red(string)}`;\n      throw new TypeError(`${name}: ${oops}; you used:\\n${called}`);\n    }\n\n    const matched = regexp.test(string);\n    if (negated) {\n      if (!matched) return;\n      let message =\n        `Expected: ${stringify(regexp)}\\nnot to match: ` +\n        `${red(abbreviate('string', string))}`;\n      if (regexp.global) {\n        const count = string.match(regexp).length;\n        message += `\\nMatches: ${red(count)}`;\n      }\n      throw error(message, explanation);\n    }\n    if (!matched) {\n      throw error(\n        `Expected: ${stringify(regexp)}\\nto match: ` +\n          `${red(abbreviate('string', string))}`,\n        explanation\n      );\n    }\n  },\n\n  throws(fn) {\n    const args = handleArgs(this, [1, 2], arguments, 'throws');\n    const name = args[0];\n    const negated = args[1];\n    let explanation;\n    if (arguments.length === 2) {\n      explanation = arguments[0];\n      fn = arguments[1];\n    }\n    if (typeof explanation === 'function') {\n      fn = explanation;\n      explanation = undefined;\n    }\n    if (typeof fn !== 'function') {\n      throw error(`${name} expects ${green('a function')} but got ${red(fn)}`);\n    }\n\n    try {\n      fn();\n    } catch (err) {\n      if (negated) {\n        throw error(\n          `Threw an exception despite ${name} assertion:\\n` + `${err.message}`,\n          explanation\n        );\n      }\n      return err;\n    }\n\n    if (negated) return null;\n    throw error(\"Didn't throw an exception as expected to\", explanation);\n  },\n\n  hasType(expectedType, value) {\n    const args = handleArgs(this, [2, 3], arguments, 'hasType');\n    const name = args[0];\n    const negated = args[1];\n    let explanation;\n    if (arguments.length === 3) {\n      explanation = arguments[0];\n      expectedType = arguments[1];\n      value = arguments[2];\n    }\n\n    const stringType = getNameOfType(expectedType);\n    if (types.indexOf(stringType) === -1) {\n      const badArg = stringify(expectedType);\n      const suggestions = implodeNicely(types, 'or');\n      throw new TypeError(\n        `${name}: unknown expectedType ${badArg}; you used:\\n${name} ` +\n          `${red(badArg)}, ${stringify(value)}\\nDid you mean ${suggestions}?`\n      );\n    }\n\n    const typeMatches = stringType === getTypeName(value);\n    if ((!typeMatches && !negated) || (typeMatches && negated)) {\n      value = red(stringify(value));\n      const toBeOrNotToBe = `${negated ? 'not ' : ''}to be`;\n      const message = `Expected value ${value} ${toBeOrNotToBe} of type ${stringType}`;\n      throw error(message, explanation);\n    }\n  },\n};\n\n// produce negatived versions of all the common assertion functions\nconst positiveAssertions = [\n  'truthy',\n  'equal',\n  'deepEqual',\n  'include',\n  'match',\n  'throws',\n  'hasType',\n];\npositiveAssertions.forEach(name => {\n  assertSync[nameNegative(name)] = function _oneTest() {\n    return assertSync[name].apply('!', arguments);\n  };\n});\n\n// borrowed from Q\nfunction isPromiseAlike(p) {\n  return p === Object(p) && typeof p.then === 'function';\n}\n\n// promise-specific tests\nassert = {\n  resolves(testee) {\n    const name = handleArgs(this, [1, 2], arguments, 'resolves')[0];\n    let explanation;\n    if (arguments.length === 2) {\n      explanation = arguments[0];\n      testee = arguments[1];\n    }\n\n    if (!isPromiseAlike(testee)) {\n      throw error(\n        `${name} expects ${green('a promise')} but got ${red(\n          stringify(testee)\n        )}`\n      );\n    }\n\n    if (name === 'rejects') {\n      return testee.then(() => {\n        throw error(\"Promise wasn't rejected as expected to\", explanation);\n      }, x => x);\n    }\n    return testee.catch(err => {\n      throw error(\n        'Promise was rejected despite resolves assertion:\\n' +\n          `${(err && err.message) || err}`,\n        explanation\n      );\n    });\n  },\n\n  rejects() {\n    return assert.resolves.apply('!', arguments);\n  },\n};\n\n// union of promise-specific and promise-aware wrapped synchronous tests\nif (assertSync) {\n  Object.keys(assertSync).forEach(name => {\n    const fn = assertSync[name];\n    assert[name] = function _oneTest() {\n      if (arguments.length === 0) return fn();\n      const args = [].slice.call(arguments);\n      const testee = args.pop();\n      if (isPromiseAlike(testee)) {\n        return testee.then(val => fn(...args, val));\n      }\n      return fn(...args, testee);\n    };\n  });\n}\n\nmodule.exports = assert;\n"]}